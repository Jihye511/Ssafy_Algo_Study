## 문제 요약

각 노드와 연결되는 간선이 주어짐  
이때 각 트리가 "홀짝 트리" 또는 "역홀짝 트리"가 될 수 있는지 판단하여 반환

---
## 정의
홀짝트리 -> 노드의 값과 자식이 같이 홀수 or 짝수인 경우만 존재 
역홀짝트리 -> 노드의 값과 자식이 값이 다른 경우만 존재

| 구분 | 노드 번호 | 자식 개수 | 타입 이름 |
|------|------------|------------|------------|
| 홀짝 노드 | 홀수 | 홀수 | `홀짝 노드` |
| 짝짝 노드 | 짝수 | 짝수 | `홀짝 노드` |
| 홀짝 반대 | 홀수 | 짝수 | `역홀짝 노드` |
| 짝홀 반대 | 짝수 | 홀수 | `역홀짝 노드` |
---

## 핵심 아이디어

트리의 루트를 어디로 잡느냐에 따라 "자식 개수"가 달라짐  
모든 노드를 “루트가 아닌 상태”로 가정하고 홀짝을 미리 계산

### 중요
1. 각 노드의 연결된 간선 수 구하기
   - **루트가 아닌 경우 → 자식 개수 = 간선 수 - 1** 
2. 노드 번호와 자식 개수의 홀짝이 같으면 `홀짝 노드` 아니면 `역홀짝 노드` 
3. 트리별 공식(?):
   - `역홀짝 노드`가 1개인 경우 → 그 노드를 루트로 잡으면 **홀짝 트리 가능**
   - `홀짝 노드`가 1개인 경우 → 그 노드를 루트로 잡으면 **역홀짝 트리 가능**


---

## Code

```java
import java.util.*;

public class Solution {
    public int[] solution(int[] nodes, int[][] edges) {
        Map<Integer, List<Integer>> graph = new HashMap<>(); //노드가 연속적이지 않아서 해쉬맵 사용

        //그래프 생성 부분
        for (int node : nodes) graph.put(node, new ArrayList<>());
        for (int[] e : edges) {
            graph.get(e[0]).add(e[1]);
            graph.get(e[1]).add(e[0]);
        }

        //노드가 연속적이지 않아서 방문용 set 사용
        Set<Integer> visited = new HashSet<>();
        int parityTreeCount = 0; //parity 홀 짝을 나타내는 컴터 용어래요
        int inverseParityTreeCount = 0;

        //모든 트리를 순회하기 모든 노드를 방문하여 BFS(완탐 DFS도 아마도 가능)실행
        for (int startNode : nodes) { //스타트 노드가 루트가 됨
            if (visited.contains(startNode)) continue;  //이미 방문한 노드는 패스

            int parityNodeCount = 0; //홀짝 노드 카운트
            int inverseParityNodeCount = 0; //역홀짝 노드 카운트
            //늘 먹던 BFS
            Queue<Integer> queue = new ArrayDeque<>();
            queue.add(startNode);
            visited.add(startNode);

            while (!queue.isEmpty()) { 
                int current = queue.poll();
                int degree = graph.get(current).size(); //이어진 차수의 수
                int childCount = degree - 1; //아이디어에 나왔던 식 -> 자식은 = 차수 - 1

                if ((current % 2) == (childCount % 2)) parityNodeCount++; //짝짝 or 홀홀
                else inverseParityNodeCount++;

                for (int next : graph.get(current)) {
                    if (!visited.contains(next)) {
                        visited.add(next); 
                        queue.add(next);
                    }
                }
            }

            //트리별 공식 적용
            if (inverseParityNodeCount == 1) parityTreeCount++;
            if (parityNodeCount == 1) inverseParityTreeCount++;
        }

        return new int[]{parityTreeCount, inverseParityTreeCount};
    }
}
```
---
## 시간복잡도
O(N + E) 
